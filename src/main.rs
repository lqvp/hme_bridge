use axum::response::Response;
use axum::{
    Json, Router,
    http::{HeaderMap, StatusCode},
    response::IntoResponse,
    routing::post,
};
use chrono::{TimeZone, Utc};
use serde::{Deserialize, Serialize};

mod icloud;
use crate::icloud::HmeEmail;
use std::net::SocketAddr;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

#[tokio::main]
async fn main() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "hme_bridge=info,tower_http=info".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();

    let app = Router::new().route("/api/alias/random/new", post(create_random_alias));

    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    tracing::debug!("listening on {}", addr);
    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

#[derive(Deserialize)]
struct CookieObject {
    name: String,
    value: String,
}

fn parse_cookies_from_json(json_str: &str, keys: &[&str]) -> Result<String, serde_json::Error> {
    let cookies: Vec<CookieObject> = serde_json::from_str(json_str)?;
    let cookie_header = cookies
        .into_iter()
        .filter(|c| keys.contains(&c.name.as_str()))
        .map(|c| format!("{}={}", c.name, c.value))
        .collect::<Vec<String>>()
        .join("; ");
    Ok(cookie_header)
}

async fn create_random_alias(
    headers: HeaderMap,
    Json(payload): Json<CreateAliasRequest>,
) -> Result<Json<Alias>, Response> {
    tracing::info!("Received request: POST /api/alias/random/new");
    tracing::debug!("Headers: {:#?}", headers);
    tracing::debug!("Request Body: {:#?}", payload);

    let keys_to_use = &[
        "X-APPLE-DS-WEB-SESSION-TOKEN",
        "X-APPLE-WEBAUTH-TOKEN",
        "X-APPLE-WEBAUTH-USER",
    ];

    let api_key = match headers.get("authentication") {
        Some(value) => value.to_str().unwrap_or(""),
        None => {
            return Err(
                (StatusCode::UNAUTHORIZED, "Authentication header is missing").into_response(),
            );
        }
    };

    if api_key.is_empty() {
        return Err((StatusCode::UNAUTHORIZED, "Authentication header is empty").into_response());
    }

    let cookie_header = match parse_cookies_from_json(api_key, keys_to_use) {
        Ok(header) => header,
        Err(_) => {
            return Err((
                StatusCode::BAD_REQUEST,
                "API Key or cookie.txt is not a valid JSON array of cookie objects",
            )
                .into_response());
        }
    };

    if cookie_header.is_empty() {
        return Err((
            StatusCode::UNAUTHORIZED,
            "Required cookies not found in API Key or cookie.txt",
        )
            .into_response());
    }
    tracing::debug!("Using Cookie Header: {}", cookie_header);

    let note = payload
        .note
        .unwrap_or_else(|| "Generated by Bitwarden.".to_string());
    let label = "Generated by hme_bridge"; // You might want to use hostname later

    match icloud::generate_and_reserve_hme(&cookie_header, label, &note).await {
        Ok(hme_email) => {
            let alias = hme_to_alias(hme_email);
            tracing::debug!(
                "Response Body:\n{}",
                serde_json::to_string_pretty(&alias).unwrap()
            );
            Ok(Json(alias))
        }
        Err(e) => {
            tracing::error!("Failed to generate HME: {}", e);
            Err((StatusCode::INTERNAL_SERVER_ERROR, e.to_string()).into_response())
        }
    }
}

fn hme_to_alias(hme: HmeEmail) -> Alias {
    let mailbox = Mailbox {
        id: 1, // dummy id
        email: hme
            .forward_to_email
            .unwrap_or_else(|| "forwarding-not-set@icloud.com".to_string()),
    };
    Alias {
        id: 1, // dummy id
        alias: hme.hme,
        name: Some(hme.label),
        enabled: hme.is_active,
        creation_timestamp: hme.create_timestamp,
        creation_date: Utc
            .timestamp_millis_opt(hme.create_timestamp)
            .unwrap()
            .to_rfc3339(),
        note: Some(hme.note),
        nb_block: 0,
        nb_forward: 0,
        nb_reply: 0,
        support_pgp: false,
        disable_pgp: false,
        mailbox: mailbox.clone(),
        mailboxes: vec![mailbox],
        latest_activity: None,
        pinned: false,
    }
}

#[derive(Debug, Deserialize)]
struct CreateAliasRequest {
    note: Option<String>,
}

#[derive(Serialize, Deserialize)]
struct Alias {
    id: i32,
    alias: String,
    name: Option<String>,
    enabled: bool,
    creation_timestamp: i64,
    creation_date: String,
    note: Option<String>,
    nb_block: i32,
    nb_forward: i32,
    nb_reply: i32,
    support_pgp: bool,
    disable_pgp: bool,
    mailbox: Mailbox,
    mailboxes: Vec<Mailbox>,
    latest_activity: Option<Activity>,
    pinned: bool,
}

#[derive(Serialize, Deserialize, Clone)]
struct Mailbox {
    id: i32,
    email: String,
}

#[derive(Serialize, Deserialize)]
struct Activity {
    action: String,
    timestamp: i64,
    contact: Contact,
}

#[derive(Serialize, Deserialize)]
struct Contact {
    email: String,
    name: Option<String>,
    reverse_alias: String,
}
