use chrono::{TimeZone, Utc};
use serde::{Deserialize, Serialize};
use worker::*;

mod icloud;
use crate::icloud::HmeEmail;

fn log_request(req: &Request) {
    console_log!(
        "{} - [{}], located at: {:?}, within: {}",
        Date::now().to_string(),
        req.path(),
        req.cf().and_then(|cf| cf.coordinates()).unwrap_or_default(),
        req.cf()
            .and_then(|cf| cf.region())
            .unwrap_or_else(|| "unknown region".into())
    );
}

#[event(fetch)]
pub async fn main(req: Request, env: Env, _ctx: Context) -> Result<Response> {
    log_request(&req);

    // Optionally, get more helpful error messages written to the console in the case of a panic.
    console_error_panic_hook::set_once();

    let router = Router::new();

    router
        .post_async("/api/alias/random/new", |mut req, _ctx| async move {
            let keys_to_use = &[
                "X-APPLE-DS-WEB-SESSION-TOKEN",
                "X-APPLE-WEBAUTH-TOKEN",
                "X-APPLE-WEBAUTH-USER",
            ];

            let api_key = match req.headers().get("authentication") {
                Ok(Some(value)) => value,
                _ => return Response::error("Authentication header is missing", 401),
            };

            if api_key.is_empty() {
                return Response::error("Authentication header is empty", 401);
            }

            let cookie_header = match parse_cookies_from_json(&api_key, keys_to_use) {
                Ok(header) => header,
                Err(_) => {
                    return Response::error(
                        "API Key or cookie.txt is not a valid JSON array of cookie objects",
                        400,
                    );
                }
            };

            if cookie_header.is_empty() {
                return Response::error("Required cookies not found in API Key or cookie.txt", 401);
            }

            let payload: CreateAliasRequest = match req.json().await {
                Ok(p) => p,
                Err(_) => return Response::error("Bad request", 400),
            };

            let note = payload
                .note
                .unwrap_or_else(|| "Generated by Bitwarden.".to_string());
            let label = "Generated by hme_bridge";

            match icloud::generate_and_reserve_hme(&cookie_header, label, &note).await {
                Ok(hme_email) => {
                    let alias = hme_to_alias(hme_email);
                    Response::from_json(&alias)
                }
                Err(e) => {
                    console_error!("Failed to generate HME: {}", e);
                    Response::error(format!("Internal Server Error: {}", e), 500)
                }
            }
        })
        .run(req, env)
        .await
}

#[derive(Deserialize)]
struct CookieObject {
    name: String,
    value: String,
}

fn parse_cookies_from_json(
    json_str: &str,
    keys: &[&str],
) -> std::result::Result<String, serde_json::Error> {
    let cookies: Vec<CookieObject> = serde_json::from_str(json_str)?;
    let cookie_header = cookies
        .into_iter()
        .filter(|c| keys.contains(&c.name.as_str()))
        .map(|c| format!("{}={}", c.name, c.value))
        .collect::<Vec<String>>()
        .join("; ");
    Ok(cookie_header)
}

fn hme_to_alias(hme: HmeEmail) -> Alias {
    let mailbox = Mailbox {
        id: 1, // dummy id
        email: hme
            .forward_to_email
            .unwrap_or_else(|| "forwarding-not-set@icloud.com".to_string()),
    };
    Alias {
        id: 1, // dummy id
        alias: hme.hme,
        name: Some(hme.label),
        enabled: hme.is_active,
        creation_timestamp: hme.create_timestamp,
        creation_date: Utc
            .timestamp_millis_opt(hme.create_timestamp)
            .unwrap()
            .to_rfc3339(),
        note: Some(hme.note),
        nb_block: 0,
        nb_forward: 0,
        nb_reply: 0,
        support_pgp: false,
        disable_pgp: false,
        mailbox: mailbox.clone(),
        mailboxes: vec![mailbox],
        latest_activity: None,
        pinned: false,
    }
}

#[derive(Debug, Deserialize)]
struct CreateAliasRequest {
    note: Option<String>,
}

#[derive(Serialize, Deserialize)]
struct Alias {
    id: i32,
    alias: String,
    name: Option<String>,
    enabled: bool,
    creation_timestamp: i64,
    creation_date: String,
    note: Option<String>,
    nb_block: i32,
    nb_forward: i32,
    nb_reply: i32,
    support_pgp: bool,
    disable_pgp: bool,
    mailbox: Mailbox,
    mailboxes: Vec<Mailbox>,
    latest_activity: Option<Activity>,
    pinned: bool,
}

#[derive(Serialize, Deserialize, Clone)]
struct Mailbox {
    id: i32,
    email: String,
}

#[derive(Serialize, Deserialize)]
struct Activity {
    action: String,
    timestamp: i64,
    contact: Contact,
}

#[derive(Serialize, Deserialize)]
struct Contact {
    email: String,
    name: Option<String>,
    reverse_alias: String,
}
